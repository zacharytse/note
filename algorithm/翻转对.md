[TOC]
# 题目
给定一个数组 nums ，如果 i < j 且 nums[i] > 2*nums[j] 我们就将 (i, j) 称作一个重要翻转对。

你需要返回给定数组中的重要翻转对的数量。

示例:
```
输入: [1,3,2,3,1]
输出: 2
```
# 思路
使用归并排序，对于排完序的两部分数组，重要翻转对的个数是两部分数组中各自的重要翻转对的个数加上左右端点分布在两个数组之间的重要翻转对个数
```java{.line-numbers}
class Solution {
    public int reversePairs(int[] nums) {
        if(nums.length < 2) {
            return 0;
        }
        return countRecursizeReversePairs(nums,0,nums.length - 1);
    }

    private int countRecursizeReversePairs(int[] nums,int low,int high) {
        if(low >= high) {
            return 0;
        }
        int mid = low + (high - low) / 2;
        int n1 = countRecursizeReversePairs(nums,low,mid);
        int n2 = countRecursizeReversePairs(nums,mid+1,high);
        int ret = n1 + n2;
        int i = low , j = mid + 1;
        while(i <= mid) {
            while(j <= high && (long)nums[i] > 2 * (long)nums[j]) {
                ++j;
            }
            ret += j - mid - 1;
            ++i;
        }
        //合并排序数组
        int[] temp = new int[high - low + 1];
        int p1 = low , p2 = mid + 1;
        int p = 0;
        while(p1 <= mid || p2 <= high) {
            if(p1 > mid) {
                temp[p++] = nums[p2++];
            } else if(p2 > high) {
                temp[p++] = nums[p1++];
            } else if(nums[p1] < nums[p2]) {
                temp[p++] = nums[p1++];
            } else {
                temp[p++] = nums[p2++];
            }
        }
        for(i = low; i <= high; ++i) {
            nums[i] = temp[i - low];
        }
        return ret; 
    }
}
```