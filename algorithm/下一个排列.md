[TOC]
# 题目
实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须原地修改，只允许使用额外常数空间。

# 思路
题目目标是为了找一个和当前排列相比较大，但相较于原来的值变化又不太大的排列。
可以先从右往左找一个较小的数(nums[i] < nums[i+1])，下标为i，然后再从右往左找一个比这个较小的数要大一点的数，下标为j，将两者进行交换。
此时区间[i+1,nums.length - 1]一定是一个递减区间，所以找到的j一定是这个区间中最小的数，和i交换后，也仍然保持递减的性质。同时为了保证与原来的值相比变化不大，所以要把区间[i+1,nums.length-1]进行逆转，使其递增
```java{.line-numbers}
class Solution {
    public void nextPermutation(int[] nums) {
        int i = nums.length - 2;
        while(i >= 0 && nums[i] >= nums[i + 1]){
            --i;
        }
        if(i >= 0){
            int j = nums.length - 1;
            while(j >= i+1 && nums[i] >= nums[j]){//要找一个完全比nums[i]大的数
                --j;
            }
            int temp = nums[i];
            nums[i] = nums[j];
            nums[j] = temp;
        }
        reverse(nums,i + 1, nums.length - 1);
    }

    private void reverse(int[] nums,int low ,int high){
        while(low < high){
            int temp = nums[low];
            nums[low] = nums[high];
            nums[high] = temp;
            ++low;
            --high;
        }
    }
}
```
