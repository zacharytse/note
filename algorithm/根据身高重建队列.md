[TOC]
# 题目
假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。

注意：
总人数少于1100人。

示例
> 输入:
> \[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]
> 输出:
> \[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]

# 思路
## 方法一 从低到高考虑
先假设所有人的身高都不相同，然后按身高从低到高进行排序。如果有n个人的话，排序结束后的序列为$h_0,h_1,...,h_{n-1}$。对于第i个人来说，有两种情况
- 前面的i-1个人身高都比第i个人矮，这i-1个人先插入到最后的结果后，不会影响第i个人在最终队列中的位置
- i+1到第n-1个人身高都比第i个人高，他们插入到队列中之后，必然会影响第i个人的位置。

所以在第i个人插入后，前面必然要留出$k_i$个空给身高比第i个人高的人插入。因此第i个人在队列中的最终位置应该是$k_i+1$个空位

接下来考虑身高相同的情况。如果两个人身高相同，也就是$h_i=h_j$,如果$k_i>k_j$,说明i在队列中的位置应该在j的后面。所以可以认为i不会影响j最终的位置，因此应该把$h_i$适当缩小，也就是让第i个人在排序完成后在j的前面。实现时，可以让k排逆序，使得当$k_i>k_j$时，排序结果为第i个人在第j个人的前面

总结下来，就是以h为第一关键字排正序，以k为第二关键字排逆序，最后每个人的位置为[0,i]中的第$h_i+1$个空位
```java{.line-numbers}
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        Arrays.sort(people, new Comparator<int[]>() {
            public int compare(int[] person1, int[] person2) {
                if (person1[0] != person2[0]) {
                    return person1[0] - person2[0];
                } else {
                    return person2[1] - person1[1];
                }
            }
        });
        int n = people.length;
        int[][] ans = new int[n][];
        for (int[] person : people) {
            int spaces = person[1] + 1;
            for (int i = 0; i < n; ++i) {
                if (ans[i] == null) {
                    --spaces;
                    if (spaces == 0) {
                        ans[i] = person;
                        break;
                    }
                }
            }
        }
        return ans;
    }
}
```
## 方法二 从高到低考虑
和方法一类似，身高从高到低排完序后，对于第i个人，要考虑两种情况
- 前面的i-1个人身高都比第i个人要高，所以他们的插入位置会影响到第i个人的位置
- i+1到n-1个人的身高都比第i个人要矮，所以他们的插入位置对于第i个人来说，没有任何影响

前面的i-1个人都插入到队列后，因为后面的人的位置不会影响到第i个人，所以第i个人的位置是确定的，应该插在队列的$k_i+1$处,这样一定能保证第i个人前面有$k_i$个人身高比他高

考虑身高相同的情况，当$h_i=h_j$时，如果$k_i>k_j$，第i个人在队列中的位置应该在第j个人后面，所以第i个人的插入不应该影响到第j个人，所以希望在排序之后，第i个人可以直接排到第j个人后面。

综上，应该以h为第一关键字倒序排序，以k为第二关键字正序排序，最后对于每个人i,应该插入到队列的$k_i$处
```java{.line-numbers}
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        Arrays.sort(people, new Comparator<int[]>() {
            public int compare(int[] person1, int[] person2) {
                if (person1[0] != person2[0]) {
                    return person2[0] - person1[0];
                } else {
                    return person1[1] - person2[1];
                }
            }
        });
        List<int[]> ans = new ArrayList<int[]>();
        for (int[] person : people) {
            ans.add(person[1], person);
        }
        return ans.toArray(new int[ans.size()][]);
    }
}
```