[TOC]
给你两个数组，arr1 和 arr2，

- arr2 中的元素各不相同
- arr2 中的每个元素都出现在 arr1 中

对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。

提示：

- arr1.length, arr2.length <= 1000
- 0 <= arr1[i], arr2[i] <= 1000
- arr2 中的元素 arr2[i] 各不相同
- arr2 中的每个元素 arr2[i] 都出现在 arr1 中

# 思路
由提示0 <= arr1[i], arr2[i] <= 1000可以想到使用计数排序。先用一个数组记录arr1中每一个数出现的个数，然后遍历arr2，将arr2中的元素按arr1中出现的个数填充到最后的结果中，并将遍历过的元素个数置为0。接着遍历记录出现次数的数组，将其中仍然不为0的元素对应的下标填充到最后结果中。
```java{.line-numbers}
class Solution {
    public int[] relativeSortArray(int[] arr1, int[] arr2) {
        int[] ans = new int[arr1.length];
        int[] counts = new int[1001];
        int idx = 0;
        for(int i = 0; i < arr1.length; ++i){
            ++counts[arr1[i]];
        }
        for(int i = 0; i < arr2.length; ++i){
            while(counts[arr2[i]] != 0){
                ans[idx++] = arr2[i];
                --counts[arr2[i]];
            }
        }
        for(int i = 0; i < counts.length; ++i){
            while(counts[i] != 0){
                ans[idx++] = i;
                --counts[i];
            }
        }
        return ans;
    }
}
```