[TOC]
# 题目
给定一个字符串S，检查是否能重新排布其中的字母，使得两相邻的字符不同。

若可行，输出任意可行的结果。若不可行，返回空字符串。

示例:
```
输入: S = "aab"
输出: "aba"
```
# 思路
要构成题目中的字符串，首先要先考虑原字符串需要满足什么样的条件。对于出现次数最多的字符，要保证它的相邻位置和它是不一样的字符，显然该字符的个数不能超过字符串长度的一半。
- 当字符串长度为偶数时，对于某一个字符，它允许出现的最大次数应该是n/2
- 当字符串长度为奇数时，对于某一个字符，它允许出现的最大次数应该是(n + 1) / 2

因为是向下取整的，所以当字符串长度为偶数时，n/2和(n+1)/2的值是相等的，所以字符串中的字符允许出现的最大次数为(n+1)/2，如果超过了这个次数，则不可能构成符合题目条件的字符串。
对于字符出现的次数，可以通过hash表来统计。统计完成后，就是要构造这个字符串

## 方法一
采用大顶堆。将每个字符根据它的出现次数放入大顶堆中。每次从堆中取2个字符，将它们拼接在一起，然后出现次数都各减一，如果剩余的出现次数不为0的话，则继续放入堆中。如果堆中元素个数仅剩一个的话，则将其取出，放到结果的末尾，并返回结果。
```java{.line-numbers}
class Solution {
    public String reorganizeString(String s) {
        Comparator<Pair<Integer,Character>> comparator = null;
        comparator = new Comparator<>() {
            public int compare(Pair<Integer,Character> p1,Pair<Integer,Character> p2) {
                return p2.getKey() - p1.getKey();
            }
        };
        PriorityQueue<Pair<Integer,Character>> queue =  
                    new PriorityQueue<>(comparator);
        int[] dict = countCharacter(s);
        int maxCount = (s.length() + 1) / 2;
        for(int i = 0; i < dict.length; ++i) {
            if(dict[i] != 0) {
                if(dict[i] > maxCount) {
                    return "";
                }
                Pair<Integer,Character> p = 
                        new Pair<>(dict[i],(char)(i + 'a'));
                queue.offer(p);
            }
        }
        StringBuilder builder = new StringBuilder();
        char last = 0;
        while(!queue.isEmpty()) {
            Pair<Integer,Character> p1 = queue.poll();
            Pair<Integer,Character> p2 = null;
            if(!queue.isEmpty()) {
                p2 = queue.poll();
            } else {
                builder.append(p1.getValue());
                return builder.toString();
            }
            builder.append(p1.getValue());
            builder.append(p2.getValue());
            int count1 = p1.getKey() - 1;
            int count2 = p2.getKey() - 1;
            if(count1 != 0) {
                queue.offer(
                    new Pair<Integer,Character>(count1,p1.getValue()));
            }
            if(count2 != 0) {
                queue.offer(
                    new Pair<Integer,Character>(count2,p2.getValue()));
            }
        }
        return builder.toString();
    }

    private int[] countCharacter(String s) {
        int[] dict = new int[26];
        for(int i = 0; i < s.length(); ++i) {
            ++dict[s.charAt(i) - 'a'];
        }
        return dict;
    }
}
```
## 方法二
计数法
当n是奇数且出现最多的字母次数为(n+1)/2时，则出现次数最多的这个字母必须放在偶数位下标，否则一定会出现相同字母相邻的情况(偶数位比奇数位多一个，放在奇数位，一定会有一个字母被放在偶数位，此时会出现相邻)

首先考虑能不能放在奇数位，只要字母出现的次数不超过字符串长度的一半(n/2),就可以放置在奇数下标。只有当字母出现次数超过字符串长度的一半时，才必须放在偶数下标(只有在n为奇数时才会出现这种情况)。这时也最多只有一个字母出现的次数会超过字符串的一半。

具体操作如下:
- 如果字母出现的次数小于等于n/2，且oddIndex没有超出数组的下标范围，则将字母放在oddIndex，并且oddIndex+2
- 如果字母出现次数大于n/2，或者oddIndex超出数组的下标范围，则将字母放在evenIndex，并且evenIndex+2

证明如下:
1. 当n为奇数，且字母出现的最大次数为(n+1)/2，则该字母可以占满所有的偶数位，此时一定不可能出现相邻的情况
2. 如果一个字母全部被放在偶数位或者奇数位，则不可能出现相邻的情况
3. 如果同一个字母先被放在了奇数位，当奇数位超出了数组范围后，才将其放到偶数位。
    - 当n为偶数时，如果该字母出现次数为n/2，奇数位下标个数为p，偶数位下标个数为q，p+q=n/2,且最小奇数位下标为n+1-2(p-1) = n-2p+1,最大的偶数位下标为2(q-1),两者之差为3
    - 当n为奇数时，如果该字母出现次数为(n-1)/2,奇数位下标个数为p，偶数位下标个数为q，p+q=(n-1)/2,且最小奇数位下标为n-1-2(p-1)=n-2p，最大偶数位下标为2(q-1),两者之差为3

    综上，最小的奇数位下标和最大的偶数位下标之差大于等于3，因此两者是不可能相邻的。
综上，算法成立
```java{.line-numbers}
class Solution {
    public String reorganizeString(String S) {
        int[] counts = new int[26];
        int n = S.length();
        int maxCount = 0;
        for(int i = 0; i < n; ++i) {
            ++counts[S.charAt(i) - 'a'];
            if(counts[S.charAt(i) - 'a'] > maxCount) {
                maxCount = counts[S.charAt(i) - 'a'];
            }
        }
        if(maxCount > (n + 1) / 2) {
            return "";
        }
        char[] arr = new char[n];
        int oddIndex = 1 , evenIndex = 0;
        int halfLength = n / 2;
        for(int i = 0; i < counts.length; ++i) {
            while(counts[i] > 0 && counts[i] <= halfLength && oddIndex < n) {
                arr[oddIndex] = (char)(i + 'a');
                --counts[i];
                oddIndex += 2;
            }
            while(counts[i] > 0) {
                arr[evenIndex] = (char)(i + 'a');
                --counts[i];
                evenIndex += 2;
            }
        }
        return new String(arr);
    }
}
```


