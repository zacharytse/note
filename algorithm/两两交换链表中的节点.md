[TOC]
#题目
给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

**你不能只是单纯的改变节点内部的值**，而是需要实际的进行节点交换。
#基本思路
采用递归的思想
分解子问题，首先是当前的子节点要进行交换，其次后面的子链表也要完成两两节点之间的互换
```ditaa {cmd=true args=["-E"] hide=true}
                      +------------------------+
+------+    +------+  | +------+    +------+   | 
|      |    |      |  | |      |    |      |   |
|  A   |--->|  B   |--+ |  C   |--->|  D   |...|
|      |    |      |  | |      |    |      |   |
+------+    +------+  | +------+    +------+   | 
    ^            ^    +------------------------+                      
    |            |
    +------------+
```
由上图可以看到，A,B交换完之后，C,D以及后面的链表仍然需要进行交换，也就是方框框起来的就代表是后面的子问题，后面子问题完成之后，只要把A(A和B互换位置后,A在B的后面)和后面的链表连接起来即可
```ditaa{cmd=true args=["-E"] hide=true}
                      +-----------------------+
+------+    +------+  |+------+    +------+   |
|      |    |      |  ||      |    |      |   |
|  B   |--->|  A   |..+|  D   |--->|  C   |...|
|      |    |      |  ||      |    |      |   |
+------+    +------+  |+------+    +------+   |
                      +-----------------------+
```
方框中的即为交换过后的子问题
```java{.line-numbers}
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {
        if(head == null || head.next == null){
            return head;
        }
        ListNode tail = head.next;
        ListNode next = tail.next;
        tail.next = head;
        head.next = swapPairs(next);
        return tail;
    }
}
```