[TOC]
# 题目
在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。

你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。

如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。

示例：
```
输入: 
gas  = [1,2,3,4,5]
cost = [3,4,5,1,2]

输出: 3

解释:
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
因此，3 可为起始索引。
```
# 思路
## 方法一
直接暴力求解
```java{.line-numbers}
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int n = gas.length;
        for(int start = 0; start < n; ++ start){
            int end = start;
            int oil = gas[start];
            int count = 0;
            while(count < n){
                int next = (end + 1) % n;
                oil -= cost[end];
                if(oil < 0){
                    break;
                }
                oil += gas[next]; 
                end = next;
                ++count;
            }
            if(count == n) {
                return start;
            }
        }
        return -1;
    }
}
```
## 方法二
对方法一做的优化。
假设从加油站x出发，第一个无法到达的加油站为y，那么必须满足的式子如下
$$
\sum_{i=x}^ycost[i]>\sum_{i=x}^ygas[i]\\
\sum_{i=x}^jgas[i]>=\sum_{i=x}^jcost[i]\space(For\space all\space j \in [x,y))
$$
其中第一个式子表示x无法到达y，第二个式子表示x可以到达y之前所有的加油站
考虑从x到y之间任意一个加油站z，能否到达加油站y，即考虑$\sum_{i=z}^ygas[i]$与$\sum_{i=z}^ycost[i]$之间的关系
根据最上面的两个式子，我们可以得到
$$
\sum_{i=z}^ygas[i]=\sum_{i=x}^ygas[i]-\sum_{i=x}^{z-1}gas[i]\\
<\sum_{i=x}^ycost[i]-\sum_{i=x}^{z-1}gas[i]\\
<\sum_{i=x}^ycost[i]-\sum_{i=x}^{z-1}cost[i]\\=\sum_{i=z}^ycost[i]
$$
所以是首先检查第0个加油站，找到第一个无法到达的加油站x，然后下一次就从加油站x+1开始检查。
```java{.line-numbers}
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int n = gas.length;
        int i = 0;
        while(i < n){
            int cnt = 0;
            int sumOfGas = 0;
            int sumOfCost = 0;
            while(cnt < n){
                int j = (i + cnt) % n;
                sumOfCost += cost[j];
                sumOfGas += gas[j];
                if(sumOfCost > sumOfGas) {
                    break;
                }
                ++cnt;
            }
            if(cnt == n){
                return i;
            } else {
                i += cnt + 1;
            }
        }
        return -1;
    }
}
```

