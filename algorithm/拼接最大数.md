[TOC]
# 题目
给定长度分别为 m 和 n 的两个数组，其元素由 0-9 构成，表示两个自然数各位上的数字。现在从这两个数组中选出 k (k <= m + n) 个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。

求满足该条件的最大数。结果返回一个表示该最大数的长度为 k 的数组。

说明: 请尽可能地优化你算法的时间和空间复杂度。

示例:
```
输入:
nums1 = [3, 4, 6, 5]
nums2 = [9, 1, 2, 5, 8, 3]
k = 5
输出:
[9, 8, 6, 5, 3]
```
# 思路
先使用单调栈选出最大的子序列，然后把这个子序列合并，并和当前求出的最大序列做比较，然后更新最大序列
```java{.line-numbers}
class Solution {
    public int[] maxNumber(int[] nums1, int[] nums2, int k) {
        int m = nums1.length , n = nums2.length;
        int start = Math.max(0,k-n) , end = Math.min(k,m);
        int[] maxSubsequence = new int[k];
        for(int i = start; i <= end; ++i) {
            int[] curSubsequence1 = getSubSequence(nums1,i);
            int[] curSubsequence2 = getSubSequence(nums2,k - i);
            int[] curMaxSubsequence = merge(curSubsequence1,curSubsequence2);
            if(compare(curMaxSubsequence,0,maxSubsequence,0) > 0) {
                maxSubsequence = curMaxSubsequence;
            }
        }
        return maxSubsequence;
    }

    int[] getSubSequence(int[] nums,int k) {
        int[] stack = new int[k];
        int top = -1;
        //remain代表可以丢掉的元素个数
        int remain = nums.length - k;
        for(int i = 0; i < nums.length; ++i) {
            int num = nums[i];
            while(top >= 0 && stack[top] < num && remain > 0) {
                --top;
                --remain;
            }
            if(top < k - 1) {
                stack[++top] = nums[i];
            } else {
                //该元素不要了，已经满了
                remain--;
            }
        }
        return stack;
    }

    int[] merge(int[] nums1,int[] nums2) {
        if(nums1.length == 0) {
            return nums2;
        }
        if(nums2.length == 0) {
            return nums1;
        }
        int mergeLength = nums1.length + nums2.length;
        int[] merge = new int[mergeLength];
        int idx = 0;
        int p1 = 0 , p2 = 0;
        while(p1 < nums1.length || p2 < nums2.length) {
            if(p1 >= nums1.length) {
                merge[idx++] = nums2[p2++];
                continue;
            }
            if(p2 >= nums2.length) {
                merge[idx++] = nums1[p1++];
                continue;
            }
            //这里不直接用nums1[p1]和nums2[p2]比较
            //是因为要保证合并后的数是最大的
            //所以相等时，选择的策略应该是要保证选了这个数以后
            //后面剩下的数尽量最大
            if(compare(nums1,p1,nums2,p2) > 0) {
                merge[idx++] = nums1[p1++];
            } else {
                merge[idx++] = nums2[p2++];
            }
        }
        return merge;
    }

    int compare(int[] nums1,int idx1,int[] nums2,int idx2) {
        int n1 = nums1.length , n2 = nums2.length;
        while(idx1 < n1 && idx2 < n2) {
            int difference = nums1[idx1] - nums2[idx2];
            if(difference != 0) {
                return difference;
            }
            ++idx1;
            ++idx2;
        }
        return (n1 - idx1) - (n2 - idx2);
    }
}
```