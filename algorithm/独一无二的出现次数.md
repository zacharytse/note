[TOC]
# 题目
给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。

如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。

 1 <= arr.length <= 1000
-1000 <= arr[i] <= 1000

# 基本思路
**方法一**
使用一次hash记录所有数据出现的次数，然后再使用set，把这些统计出现的次数加入到set中，判断加入set的数据总量和set的size大小是否一致，如果一致，则说明没有重复，否则返回false
```java{.line-numbers}
class Solution {
    public boolean uniqueOccurrences(int[] arr) {
        int[] counts = new int[2001];
        for(int i = 0; i < arr.length;++i){
            ++counts[arr[i] + 1000];
        }
        Set<Integer> set = new HashSet<>();
        int sum = 0;
        for(int i = 0; i < counts.length;++i){
            if(counts[i] == 0){
                continue;
            }
            set.add(counts[i]);
            ++sum;
        } 
        return set.size() == sum ? true : false;
    }
}
```
**方法二**
先对数组进行排序，然后用一个flag数组记录每一个数据出现的次数，比如某一个数出现了2次，则flag[2] = true。然后在遍历过程中，如果发现flag[i]是true，则说明这个次数已经出现过了，此时返回false。在最后的时候，因为最后一个元素循环之后，会跳出循环，所以最后不能直接返回true，而应该返回!flag[j - i]
```java{.line-numbers}
class Solution {
    public boolean uniqueOccurrences(int[] arr) {
        Arrays.sort(arr);
        boolean[] flag = new boolean[arr.length + 1];
        int i = 0, j = i + 1;
        for(;j < arr.length;++j){
            if(arr[j] != arr[i]){
                if(flag[j - i]){
                    return false;
                }
                flag[j - i] = true;
                i = j;
            }
        }
        return !flag[j - i];
    }
}
```