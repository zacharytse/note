[TOC]
#题目
你将会获得一系列视频片段，这些片段来自于一项持续时长为 T 秒的体育赛事。这些片段可能有所重叠，也可能长度不一。
视频片段 clips[i] 都用区间进行表示：开始于 clips[i][0] 并于 clips[i][1] 结束。我们甚至可以对这些片段自由地再剪辑，例如片段 [0, 7] 可以剪切成 [0, 1] + [1, 3] + [3, 7] 三部分。

我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（[0, T]）。返回所需片段的最小数目，如果无法完成该任务，则返回 -1 。
#基本思路
##方法一
**动态规划**
定义dp[i]为覆盖区间[0,i)需要的最少片段数。对于区间$[a_j,b_j]$,如果$a_j < i <= b_j$,那么可以认为区间$[a_j,b_j]$覆盖了[0,i)的后半段$[a_j,i)$,那么只需要再加上前半段$[0,a_j)$的最优解，就可以求出覆盖区间[0,i)所需要的最少片段数。前半段需要的区间数可以用$dp[a_j]$来表示，那么最后的方程可以表示为
$$
dp[i] = min(dp[a_j]) + 1,a_j < i <= b_j
$$
```java{.line-numbers}
class Solution {
    public int videoStitching(int[][] clips, int T) {
        int[] dp = new int[T + 1];
        Arrays.fill(dp,Integer.MAX_VALUE - 1);
        dp[0] = 0;
        for(int i = 1; i <= T;++i){
            for(int[] clip : clips){
                if(clip[0] < i && clip[1] >= i){
                    dp[i] = Math.min(dp[i],dp[clip[0]] + 1);
                }
            }
        }
        return dp[T] == Integer.MAX_VALUE - 1 ? -1 : dp[T];
    }
}
```
## 方法二
**贪心**
首先求出[0,T)中每个点可以到达的最远位置，记为maxn[i]。再枚举每一个具体的位置，当枚举到位置i时，记左端点不大于i的所有区间中最远的右端点为last。每次枚举到一个新的位置就用maxn[i]来更新last，如果更新后，last==i,那么就说明[0,i)这个区间是跨不过去的，所以最后返回-1。同时要用一个pre记录上一个区间可到达的最远位置。如果$i==pre$,则说明现在已经越过了上一个区间可覆盖的位置，因此总共需要的区间数需要加1，同时要更新pre为当前位置可到达的最远位置
```java{.line-numbers}
class Solution {
    public int videoStitching(int[][] clips, int T) {
        int[] maxn = new int[T];
        int last = 0, pre = 0 , ret = 0;
        for(int[] clip : clips){
            if(clip[0] < T){
                maxn[clip[0]] = Math.max(maxn[clip[0]],clip[1]);
            }
        }
        for(int i = 0; i < T;++i){
            last = Math.max(last,maxn[i]);
            if(last == i){
                return - 1;
            }
            if(i == pre){
                ++ret;
                pre = last;
            }
        }
        return ret;
    }
}
```