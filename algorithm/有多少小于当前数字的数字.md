[TOC]
# 题目
给你一个数组 nums，对于其中每个元素 nums[i]，请你统计数组中比它小的所有数字的数目。

换而言之，对于每个 nums[i] 你必须计算出有效的 j 的数量，其中 j 满足 j != i 且 nums[j] < nums[i] 。

以数组形式返回答案。

# 基本思路
- 方法一
使用计数排序的方法，先用数组hash记录每一个数字出现的次数，则数组中每一个比当前数小的所有数的总和即为hash[0,....i-1]的总和
```java{.line-numbers}
class Solution {
    public int[] smallerNumbersThanCurrent(int[] nums) {
        int[] hash = new int[101];
        int[] ans = new int[nums.length];
        for(int i = 0; i < nums.length;++i){
            ++hash[nums[i]];
        }
        for(int i = 1; i < hash.length;++i){
            hash[i] += hash[i - 1];
        }
        for(int i = 0; i < nums.length;++i){
            ans[i] = (nums[i] == 0 ? 0 : hash[nums[i] - 1]);
        }
        return ans;
    }
}
```
- 方法二
使用快速排序的方法。记录下数组中每个元素的下标，然后对原数组进行排序，排完序后，每个元素左边元素的数量即为小于该元素的元素数量总和
```java{.line-numbers}
class Solution {
    public int[] smallerNumbersThanCurrent(int[] nums) {
        int[][] data = new int[nums.length][2];
        int[] ans = new int[nums.length];
        for(int i = 0; i < nums.length;++i){
            data[i][0] = nums[i];
            data[i][1] = i;
        }
        Arrays.sort(data,new Comparator<int[]>(){
            public int compare(int[] data1,int[] data2){
                return data1[0] - data2[0];
            }
        });
        int prev = -1;
        for(int i = 0; i < data.length;++i){
           if(prev == -1 || data[i][0] != data[i - 1][0]){
               //考虑i==0或者元素相同的情况
               prev = i;
           }
           ans[data[i][1]] = prev;
        }
        return ans;
    }
}
```