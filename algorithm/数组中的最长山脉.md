[TOC]
#题目
我们把数组 A 中符合下列属性的任意连续子数组 B 称为 “山脉”：

B.length >= 3
存在 0 < i < B.length - 1 使得 B[0] < B[1] < ... B[i-1] < B[i] > B[i+1] > ... > B[B.length - 1]
（注意：B 可以是 A 的任意子数组，包括整个数组 A。）

给出一个整数数组 A，返回最长 “山脉” 的长度。

如果不含有 “山脉” 则返回 0。

#基本思路
通过状态定义的方法遍历整个数组。状态共有4种:INIT,UP0,UP1,DOWN，如果有一个区间能够完整的经历这4种状态，那么这个区间一定是符合题目条件的，最后求出所有满足条件的区间中长度最长的那个，并返回它的长度。
- INIT：区间的初始化状态
- UP0:区间第一次进入单调递增状态
- UP1:说明区间正式进入单调递增状态，只能从UP1转为DOWN，不能由UP0转为DOWN
- DOWN:区间的单调下降状态
这里设置两个递增状态主要是为了防止出现类似[3,2]这种情况，刚从INIT态转到UP态就直接DOWN了，是不符合题意的。
这里要注意从DOWN态切回INIT态时，i是要减2的，这是为了保证下次访问的是之前区间的最低谷的位置，而不是直接跳过这个位置,如[1,5,4,2,3],访问到3时，应该从DOWN切回INIT态，但是下次的访问位置应该是2，所以i要减2
```java{.line-numbers}
class Solution {
    public int longestMountain(int[] A) {
        final int UP0 = 0;
        final int UP1 = 1;
        final int DOWN = 2;
        final int INIT = 3;
        int STATE = INIT;
        int cur = 0 , maxDist = 0;
        for(int i = 0; i < A.length; ++i){
            switch(STATE){
                case INIT:
                    cur = i;
                    STATE = UP0;
                    break;
                case UP0:
                    if(A[i] > A[i - 1]){
                        STATE = UP1;
                    } else {
                        STATE = INIT;
                        --i;
                    }
                    break;
                case UP1:
                    if(A[i] < A[i - 1]){
                        STATE = DOWN;
                    } else if(A[i] == A[i - 1]){
                        STATE = INIT;
                        --i;
                    }
                    break;
                case DOWN:
                    if(A[i] >= A[i - 1]){
                        STATE = INIT;
                        maxDist = Math.max(maxDist,i - cur);
                        i -= 2;
                    }
                    break;
            }
        }
        if(STATE == DOWN){
            maxDist = Math.max(maxDist,A.length - cur);
        }
        return maxDist;
    }
}
```