[TOC]
# 题目
给定一个整数数组 nums，返回区间和在 [lower, upper] 之间的个数，包含 lower 和 upper。
区间和 S(i, j) 表示在 nums 中，位置从 i 到 j 的元素之和，包含 i 和 j (i ≤ j)。

# 思路
使用前缀和和归并排序。
> 前缀和在使用时，要在第一个位置加一个0，表示开始

求出前缀和preSum后，问题可以转换为找出所有满足下列条件的区间 [i,j],并统计他们的个数
$$
preSum[j] - preSum[i] \in [lower,upper]
$$
对于上面列出的表达式的求解，可以使用归并排序。考虑如下问题。对于有序数组n1和n2，需要统计满足下列条件的区间 [i,j] 个数
$$
n2[j] - n1[i] \in [lower,upper]
$$
在固定i不动的前提下，定义l，r指向n2的起始位置。要使得上述表达式满足，则必须使得$n2[l]-n1[i]>=lower$,所以要对l进行迭代，直到找到这么一个符合条件的l。同样的，也要满足表达式$n2[r] - n1[i]<=upper$,所以r也要向后迭代，直到找到一个r不满足这个表达式，那么此时$[l,r)$构成的区间即可以满足$n2[j] - n1[i] \in [lower,upper]$。
因此对于该问题来说，必须要保证preSum是有序的，所以可以考虑使用归并排序
```java{.line-numbers}
class Solution {
    public int countRangeSum(int[] nums, int lower, int upper) {
        long[] sum = new long[nums.length + 1];
        for(int i = 0; i < nums.length;++i){
            sum[i + 1] = sum[i] + nums[i];
        }
        return countRecursiveRangeSum(sum,lower,upper,0,sum.length - 1);
    }

    private int countRecursiveRangeSum(long[] sum,int lower,int upper,int left,int right){
        if(left == right){
            return 0;
        }
        int mid = (left + right) / 2;
        int n1 = countRecursiveRangeSum(sum,lower,upper,left,mid);
        int n2 = countRecursiveRangeSum(sum,lower,upper,mid + 1,right);
        int ret = n1 + n2;
        int i = left;
        int l = mid + 1;
        int r = mid + 1;
        while(i <= mid){
            while(l <= right && sum[l] - sum[i] < lower) ++l;
            while(r <= right && sum[r] - sum[i] <= upper) ++r;
            ret += r - l;
            ++i;
        }
        //合并两个排序数组
        int[] temp = new int[right - left + 1];
        int p1 = left, p2 = mid + 1;
        int p = 0;
        while(p1 <= mid || p2 <= right){
            if(p1 > mid){
                temp[p++] = (int)sum[p2++];
            } else if(p2 > right){
                temp[p++] = (int)sum[p1++];
            } else if(sum[p1] <= sum[p2]){
                temp[p++] = (int)sum[p1++];
            } else {
                temp[p++] = (int)sum[p2++];
            }
        }
        for(i = 0; i < temp.length;++i){
            sum[left + i] = temp[i];
        }
        return ret;
    }
}
```