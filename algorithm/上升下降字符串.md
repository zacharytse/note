[TOC]
# 题目
给你一个字符串 s ，请你根据下面的算法重新构造字符串：

1. 从 s 中选出 最小 的字符，将它 接在 结果字符串的后面。
2. 从 s 剩余字符中选出 最小 的字符，且该字符比上一个添加的字符大，将它接在结果字符串后面。
3. 重复步骤 2 ，直到你没法从 s 中选择字符。
4. 从 s 中选出 最大 的字符，将它 接在 结果字符串的后面。
5. 从 s 剩余字符中选出 最大 的字符，且该字符比上一个添加的字符小，将它接在结果字符串后面。
6. 重复步骤 5 ，直到你没法从 s 中选择字符。
7. 重复步骤 1 到 6 ，直到 s 中所有字符都已经被选过。

在任何一步中，如果最小或者最大字符不止一个 ，你可以选择其中任意一个，并将其添加到结果字符串。

请你返回将 s 中字符重新排序后的 结果字符串 。

示例:
```
输入：s = "aaaabbbbcccc"
输出："abccbaabccba"
解释：第一轮的步骤 1，2，3 后，结果字符串为 result = "abc"
第一轮的步骤 4，5，6 后，结果字符串为 result = "abccba"
第一轮结束，现在 s = "aabbcc" ，我们再次回到步骤 1
第二轮的步骤 1，2，3 后，结果字符串为 result = "abccbaabc"
第二轮的步骤 4，5，6 后，结果字符串为 result = "abccbaabccba"
```

# 思路
## 方法一
先对原字符串排序，然后根据题目所给步骤进行模拟
```java{.line-numbers}
class Solution {
    public String sortString(String s) {
        char[] arr = s.toCharArray();
        Arrays.sort(arr);
        StringBuilder builder = new StringBuilder();
        int count = arr.length;
        while(count > 0) {
            int minIdx = 0;
            while(arr[minIdx] == (char)-1) {
                ++minIdx;
            }
            char last = arr[minIdx];
            builder.append(arr[minIdx]);
            arr[minIdx] = (char)-1;
            --count;
            int idx = minIdx + 1;
            while(idx < arr.length && count > 0) {
                if(arr[idx] != (char)-1 && arr[idx] != last) {
                    builder.append(arr[idx]);
                    last = arr[idx];
                    arr[idx] = (char)-1;
                    --count;
                }
                ++idx;
            }
            if(count <= 0) {
                break;
            }
            int maxIdx = arr.length - 1;
            while(arr[maxIdx] == (char)-1) {
                --maxIdx;
            }
            last = arr[maxIdx];
            builder.append(arr[maxIdx]);
            arr[maxIdx] = (char)-1;
            --count;
            idx = maxIdx - 1;
            while(idx >= 0 && count > 0) {
                if(arr[idx] != (char)-1 && last != arr[idx]) {
                    builder.append(arr[idx]);
                    last = arr[idx];
                    arr[idx] = (char)-1;
                    --count;
                }
                --idx;
            }
        }
        return builder.toString();
    }
}
```
## 方法二(桶排序)
因为不关心原有字符在字符串中的位置，所以只要用一个桶记录每个字母出现的次数，然后分别从左到右和从右到左进行遍历这个桶，从桶中取出一个字母，则该字母出现次数减1，最后直到新构造的字符串的长度和原有字符串一致，则停止遍历。
```java{.line-numbers}
class Solution {
    public String sortString(String s) {
        int[] dict = new int[26];
        for(int i = 0; i < s.length(); ++i) {
            ++dict[s.charAt(i) - 'a'];
        }
        StringBuilder builder = new StringBuilder();
        while(builder.length() < s.length()) {
            for(int i = 0; i < dict.length; ++i) {
                if(dict[i] != 0) {
                    builder.append((char)(i + 'a'));
                    --dict[i];
                }
            }
            for(int i = dict.length - 1; i >= 0; --i) {
                if(dict[i] != 0) {
                    builder.append((char)(i + 'a'));
                    --dict[i];
                }
            }
        }
        return builder.toString();
    }
}
```