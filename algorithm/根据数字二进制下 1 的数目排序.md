[TOC]
# 题目
给你一个整数数组 arr 。请你将数组中的元素按照其二进制表示中数字 1 的数目升序排序。

如果存在多个数字二进制中 1 的数目相同，则必须将它们按照数值大小升序排列。

请你返回排序后的数组。

**提示**
- $1 <= arr.length <= 500$
- $0 <= arr[i] <= 10^4$

# 思路
## 方法一
暴力求解，因为每一个元素的大小是在$[0,10^4]$之间，所以可以直接用数组记录每个元素含有二进制1的个数，然后定义Comparator接口对原数组进行排序
```java{.line-numbers}
class Solution {
    public int[] sortByBits(int[] arr) {
        List<Integer> list = new ArrayList<>();
        int[] bits = new int[100001];
        for(Integer x : arr){
            list.add(x);
            bits[x] = getOneNum(x);
        }
        Collections.sort(list,new Comparator<Integer>(){
            public int compare(Integer x,Integer y){
                if(bits[x] != bits[y]){
                    return bits[x] - bits[y];
                } else {
                    return x - y;
                }
            }
        });
        for(int i = 0; i < list.size();++i){
            arr[i] = list.get(i);
        }
        return arr;
    }

    private int getOneNum(int x){
        int sum = 0;
        while(x != 0){
            sum += (x & 1);
            x >>= 1;
        }
        return sum;
    }
}
```
## 方法二
基于递推式$bits[i] = bits[i >> 1] + (i \& 1)$
```java{.line-numbers}
class Solution {
    public int[] sortByBits(int[] arr) {
        int[] bits = new int[10001];
        List<Integer> list = new ArrayList<>();
        for(int i = 1; i < bits.length; ++i){
            bits[i] = bits[i >> 1] + (i & 1);
        }
        for(Integer x : arr){
            list.add(x);
        }
        Collections.sort(list,new Comparator<Integer>(){
            public int compare(Integer x,Integer y){
                if(bits[x] != bits[y]){
                    return bits[x] - bits[y];
                } else {
                    return x - y;
                }
            }
        });
        for(int i = 0; i < arr.length; ++i){
            arr[i] = list.get(i);
        }
        return arr;
    }
}
```