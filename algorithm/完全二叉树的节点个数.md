[TOC]
# 题目
给出一个完全二叉树，求出该树的节点个数。
# 思路
## 方法一(暴力)
```java{.line-numbers}
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int countNodes(TreeNode root) {
        if(root == null){
            return 0;
        }
        return countNodes(root.left) + countNodes(root.right) + 1;
    }
}
```
## 方法二(二分查找+位运算)
对于一棵完全二叉树，如果最后一层只有一个节点，那么它的节点个数为$2^h$,如果最后一层是满节点，那么它的节点个数为$2^{h+1}-1$，也就是说对于h层的完全二叉树，它的节点个数范围是在$[2^{h},2^{h+1}-1]$中。可以使用二分查找，对于最后一层的节点k，如果k存在，说明节点个数一定是大于等于k，如果k不存在，则节点个数一定小于k。

**使用二分查找进行范围查找而不是某个数的查找时，定义mid可以向上取整，这样可以避免死循环，即mid=low + (high - low + 1)/2**

对于一棵完全二叉树，可以用二进制来表示最底层的k节点到根节点的路径。对于h层的完全二叉树，可以用h位的二进制来表示，最高位始终设为1，然后从根节点出发，如果子节点是父节点的左孩子，则为0，否则为1。可以根据这个二进制构成的路径判断k是否存在
```java{.line-numbers}
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int countNodes(TreeNode root) {
        if(root == null) {
            return 0;
        }
        int level = 0;
        TreeNode node = root;
        while(node.left != null){
            ++level;
            node = node.left;
        }
        int low = 1 << level;
        int high = (1 << (level + 1)) - 1;
        while(low < high) {
            int mid = low + (high - low + 1) / 2;
            if(exist(root,level,mid)) {
                low = mid;
            } else {
                high = mid - 1;
            }
        }
        return low;
    }

    private boolean exist(TreeNode node,int level,int k){
        TreeNode root = node;
        int bits = 1 << (level - 1);
        while(root != null && bits > 0) {
            if((bits & k) == 0) {
                root = root.left;
            } else {
                root = root.right;
            }
            bits >>= 1;
        }
        return root != null;
    }
}
```