# 基本思路

# 使用动态规划

给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

注意:

每个数组中的元素不会超过 100
数组的大小不会超过 200

**问题转换**：原问题可以转换为从原数组中选取一些数，使得这些数的和等于原数组所有数和的一半($target = sum/2$)，即0-1背包问题

定义数组$dp[i][j]$表示从数组的$[0,i]$下标范围内选取若干个整数，使得他们的和等于j，所以最后的答案为$dp[n-1][target]$

还要考虑一些特殊情况。当数组元素个数小于2个时，显然是不可进行划分的，此时返回false。当数组中最大的元素大于数组和的一半时，也是不可能进行划分的，也返回false。如果数组的和是奇数的话也是不可能进行划分的，此时也应该返回false

考虑边界情况：

i=0或者j=0的情况

当j=0时，意味着target为0，不选择数即可达到目标，所以$dp[i][0]=true$。当i=0时，显然选择nums[0]是可以的，即$dp[0][nums[0]]=true$。

对于一般情况：

当$j>=nums[i]$时，有两种情况

1. 选取当前数,则$dp[i][j]=dp[i-1][j-nums[i]]$
2. 不选取当前数,则$dp[i][j]=dp[i-1][j]$

当$j<nums[i]$时，显然$nums[i]$是不能选取的,$dp[i][j]=dp[i-1][j]$

所以，最后的表达式为
$$
dp[i][j]=
\begin{cases}
dp[i-1][j] | dp[i-1][j-nums[i]],j>=nums[i] \\
dp[i-1][j]
\end{cases}
$$
**代码**

```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        if(nums.size() < 2){
            return false;
        }
        int sum = 0;
        int maxNum = INT_MIN;
        for(int i = 0; i < nums.size();++i){
            sum += nums[i];
            if(maxNum < nums[i]){
                maxNum = nums[i];
            }
        }
        if(sum % 2 != 0){
            return false;
        }
        int target = sum / 2;
        if(maxNum > target){
            return false;
        }
        vector<vector<bool>> dp(nums.size(),vector<bool>(target + 1));
        for(int i = 0; i < nums.size();++i){
            dp[i][0] = true;
        }
        dp[0][nums[0]] = true;
        for(int i = 1; i < nums.size();++i){
            for(int j = 0; j <= target;++j){
                if(j >= nums[i]){
                    dp[i][j] = dp[i - 1][j] | dp[i - 1][j - nums[i]];
                }else{
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        return dp[nums.size() - 1][target];
    }
};
```

### 优化策略

采用滚动数组做优化，因为每次更新使用的都是上一行的值，即$dp[i-1]$这一行的值

而且j要从大到小更新，如果从小到大更新，会提前把上一行的值覆盖，造成更新时，实际用的是这一行的值的问题

```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        if(nums.size() < 2){
            return false;
        }
        int sum = 0;
        int maxNum = INT_MIN;
        for(int i = 0; i < nums.size();++i){
            sum += nums[i];
            if(maxNum < nums[i]){
                maxNum = nums[i];
            }
        }
        if(sum % 2 != 0){
            return false;
        }
        int target = sum / 2;
        if(maxNum > target){
            return false;
        }
        vector<bool> dp(target+1);
        dp[0]=true;
        dp[nums[0]] = true;
        for(int i = 1; i < nums.size();++i){
            for(int j = target; j>=1;--j){
                if(j >= nums[i]){
                    dp[j]=dp[j] | dp[j-nums[i]];
                }
            }
        }
        return dp[target];
    }
};
```
